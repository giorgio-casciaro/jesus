var R = require('ramda')
// var path = require('path')
// const uuidV4 = require('uuid/v4')
const getValuePromise = require('./jesus').getValuePromise
const checkRequired = require('./jesus').checkRequired

module.exports = async function getEntityCqrsPackage (CONFIG, DI) {
  const PACKAGE = 'entity.cqrs'
  CONFIG = checkRequired(CONFIG, ['entityName', 'mutationsStorage', 'viewsStorage', 'viewsSnapshotsStorage'], PACKAGE)
  DI = checkRequired(DI, ['throwError', 'debug', 'emitEvent'], PACKAGE)

  var mutationsStoragePackage = await CONFIG.mutationsStorage.storage(CONFIG.mutationsStorage, DI)
  var viewsStoragePackage = await CONFIG.viewsStorage.storage(CONFIG.viewsStorage, DI)
  var viewsSnapshotsStoragePackage = await CONFIG.viewsSnapshotsStorage.storage(CONFIG.viewsSnapshotsStorage, DI)
  var mutationsPackage = await require('./mutations.cqrs')(CONFIG, R.merge(DI, {mutationsStoragePackage}))
  var viewsPackage = await require('./views.cqrs')(CONFIG, R.merge(DI, {viewsStoragePackage, viewsSnapshotsStoragePackage, mutationsPackage}))
  // var validate = await require('./validate')(CONFIG, DI)
  var entityName = await getValuePromise(CONFIG.entityName)

  // function checkItemsIds (items) {  // ID AUTOGENERATED IF NOT INCLUDED
  //   items.forEach((item) => { if (!item._id)item._id = require('uuid/v4')() })
  // }

  return {
    async mutate ({itemsIds, items, mutation = 'update'}) {
      try {
        if (!itemsIds || !mutation) throw new Error('ARG itemsIds, items, mutation are required')
        // await validate({items})//TO FIX validation specifica per mutation
        var itemsMutations = await mutationsPackage.mutate({mutation, itemsIds, items})
        DI.debug({msg: `ENTITY: ${entityName} mutate()`, context: PACKAGE, debug: {itemsMutations}})
        DI.emitEvent({name: 'mutated', data: {entity: entityName, itemsIds, mutation}})
        return itemsMutations
      } catch (error) {
        DI.throwError(`ENTITY: ${entityName} mutate()`, error, {itemsIds, items, mutation})
      }
    },
    async read ({itemsIds}) {
      try {
        if (!itemsIds || !itemsIds.length) throw new Error(`ENTITY: ${entityName} read(itemsIds)  required args`)
        var items = await viewsPackage.get({ids: itemsIds})
        DI.debug({msg: `ENTITY: ${entityName} read()`, context: PACKAGE, debug: {itemsIds, items}})
        DI.emitEvent({name: 'readed', data: {entity: entityName, itemsIds: itemsIds}})
        return items
      } catch (error) {
        DI.throwError(`ENTITY: ${entityName} read()`, error, {itemsIds})
      }
    },
    async refreshViews ({itemsIds, loadSnapshot, loadMutations, addMutations}) {
      try {
        await viewsPackage.refreshItemsViews({itemsIds, loadSnapshot, loadMutations, addMutations})
        DI.emitEvent({name: 'viewsUpdated', data: {entity: entityName, itemsIds: itemsIds}})
      } catch (error) {
        DI.throwError(`ENTITY: ${entityName} refreshViews()`, error, {itemsIds, loadSnapshot, loadMutations, addMutations})
      }
    }
  }
}
